# Schema
# ======
# This document lays out the base classes for all
# the other classes in this project.
helper = require './helper'

# Continuous Entities
# ===================
# Entities that operate over data that correlates
# fixed-dimensional real-valued vectors with real-valued scalars.

# Trainer
# -------
# The base class from which all Trainers (e.g. linear regression,
# K-NN) extend. A Trainer is fed input/output pairs one by one,
# then can be called to `generate` an Estimator using the training data
# it has been fed.
exports.Trainer = class Trainer
  constructor: ->
  feed: ({input, output}) ->
  generate: -> new Estimator()

# Estimator
# ---------
# The base class from which all Estimators extend. An Estimator
# is generated by a Trainer, can can be asked to `estimate` the output
# for a given input.
exports.Estimator = class Estimator
  constructor: ->
  estimate: (input) ->

# Corpus
# ------
# A Corpus is a container for input-ouput pairs. It is
# useful to have them all in one place so that we can
# train and test against them in bulk.
exports.Corpus = class Corpus
  constructor: (@pairs) ->

  # A Corpus can be fed in bulk to a Trainer.
  feedTo: (trainer) ->
    for el in @pairs
      trainer.feed el
    return null

  # An Estimator can be tested against a corpus
  # for mean squared residuals.
  meanSquaredError: (estimator) ->
    mse = 0
    for el in @pairs
      mse += (estimator.estimate(el.input) - el.output) ** 2 / @pairs.length
    return mse

# Discrete Entities
# =================
# Entities that operate over data that correlates
# fixed-dimensional real-valued vectors with elements of a finite enumerable set.

# DiscreteTrainer
# ---------------
# Analagous to the continuous Trainer above.
exports.DiscreteTrainer = class DiscreteTrainer
  constructor: ->
  feed: ({input, output}) ->
  generate: -> new DiscreteEstimator()

# DiscreteEstimator
# -----------------
# Analagous to the continuous Estimator above,
# a DiscreteEstimator must both be able to give an
# expected answer and the estimated probabilities for each
# possible answer.
#
# For a DiscreteEstimator, `estimate` will return the best possible
# answer. `probabilities` will return a dictionary mapping possible labels
# to estimated log probabilities.
exports.DiscreteEstimator = class DiscreteEstimator
  constructor: ->
  estimate: (input) -> helper.argmax @probabilities(input)
  probabilities: (input) ->

# Classifiers
# -----------
# A simple way to do discrete classification is to run
# _n_ different continuous estimators at once.
exports.createClassifier = (BaseTrainer, labels) ->
  class ClassifierTrainer extends DiscreteTrainer
    constructor: ->
      @trainers = {}
      for label in labels
        @trainers[label] = new BaseTrainer arguments

    # When we feed such a classifier, for each input,
    # we tell each trainer that such an input was either their
    # label or not their label with a 0 or a 1.
    feed: ({input, output}) ->
      for label, trainer of @trainers
        if label is output
          trainer.feed
            input: input
            ouput: 1
        else
          trainer.feed
            input: input
            ouput: 0
      return null

    # To generate the estimator,
    # we simply tell each of our subtrainers
    # to generate an estimator and put the map in our
    # resulting model.
    generate: ->
      estimators = helper.mapmap @trainers, (trainer) -> trainer.generate()
      return new ClassifierEstimator estiamtors

  class ClassifierEstimator extends DiscreteEstimator
    constructor: (@estimators) ->
    probabilities: (input) -> helper.normalize helper.mapmap @estimators, (estimator) -> estimator.estimate input

  return ClassifierTrainer

# # DiscreteCorpus
# Analagous to the continuous Corpus above.
exports.DiscreteCorpus = class DiscreteCorpus
  constructor: (@pairs) ->

  # A DiscreteCorpus can be fed in bulk to a DiscreteTrainer
  feedTo: (trainer) ->
    for el in @pairs
      trainer.feed el
    return null

  # A DiscreteEstimator can be tested against a DiscreteCorpus
  # for cross entropy.
  crossEntropy: (estimator) ->
    cross = 0
    for el in @pairs
      cross += estimator.probabilities(el.input)[el.output] / @pairs.length
    return cross

  # A DiscreteEstimator can be tested against a DiscreteCorpus
  # for accuracy.
  accuracy: (estimator) ->
    percent = 0
    for el in @pairs
      if el.output is estimator.estimate(el.input)
        percent += 1 / @pairs.length
    return percent
